var L = (n) => {
  throw TypeError(n);
};
var R = (n, e, t) => e.has(n) || L("Cannot " + t);
var o = (n, e, t) => (R(n, e, "read from private field"), t ? t.call(n) : e.get(n)), u = (n, e, t) => e.has(n) ? L("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), c = (n, e, t, i) => (R(n, e, "write to private field"), i ? i.call(n, t) : e.set(n, t), t), l = (n, e, t) => (R(n, e, "access private method"), t);
import * as a from "three";
var m, W, j, x, U;
class I {
  /**
   * Create a SphMercProjection.
   */
  constructor() {
    u(this, m);
    this.EARTH = 4007501668e-2, this.HALF_EARTH = 2003750834e-2;
  }
  /**
   * Project a longitude and latitude into Spherical Mercator.
   * @param {number} lon - the longitude.
   * @param {number} lat - the latitude.
   * @return {Array} Two-member array containing easting and northing.
   */
  project(e, t) {
    return [l(this, m, W).call(this, e), l(this, m, j).call(this, t)];
  }
  /**
   * Unproject a Spherical Mercator easting and northing.
   * @param {Array} projected - Two-member array containing easting and northing
   * @return {Array} Two-member array containing longitude and latitude 
   */
  unproject(e) {
    return [l(this, m, x).call(this, e[0]), l(this, m, U).call(this, e[1])];
  }
  /**
   * Return the projection's ID.
   * @return {string} The value "epsg:3857".
   */
  getID() {
    return "epsg:3857";
  }
}
m = new WeakSet(), W = function(e) {
  return e / 180 * this.HALF_EARTH;
}, j = function(e) {
  var t = Math.log(Math.tan((90 + e) * Math.PI / 360)) / (Math.PI / 180);
  return t * this.HALF_EARTH / 180;
}, x = function(e) {
  return e / this.HALF_EARTH * 180;
}, U = function(e) {
  var t = e / this.HALF_EARTH * 180;
  return t = 180 / Math.PI * (2 * Math.atan(Math.exp(t * Math.PI / 180)) - Math.PI / 2), t;
};
var w, g, v, O, E, M, f, h, D, _, H, q;
class $ {
  /**
   * @param {THREE.Scene} scene - The Three.js scene to use.
   * @param {THREE.Camera} camera - The Three.js camera to use. Should usually 
   * be a THREE.PerspectiveCamera.
   * @param {Object} options - Initialisation options for the GPS; see
   * setGpsOptions() below.
   */
  constructor(e, t, i = {}) {
    u(this, h);
    u(this, w);
    u(this, g);
    u(this, v);
    u(this, O);
    u(this, E);
    u(this, M);
    u(this, f);
    this.scene = e, this.camera = t, c(this, w, new I()), c(this, g, {}), c(this, v, null), c(this, O, 0), c(this, E, 100), c(this, M, null), this.setGpsOptions(i), c(this, f, null);
  }
  /**
   * Set the projection to use.
   * @param {Object} any object which includes a project() method 
   * taking longitude and latitude as arguments and returning an array 
   * containing easting and northing.
   */
  setProjection(e) {
    c(this, w, e);
  }
  /**
   * Set the GPS options.
   * @param {Object} object containing gpsMinDistance and/or gpsMinAccuracy
   * properties. The former specifies the number of metres which the device
   * must move to process a new GPS reading, and the latter specifies the 
   * minimum accuracy, in metres, for a GPS reading to be counted.
   */
  setGpsOptions(e = {}) {
    e.gpsMinDistance !== void 0 && c(this, O, e.gpsMinDistance), e.gpsMinAccuracy !== void 0 && c(this, E, e.gpsMinAccuracy);
  }
  /**
   * Start the GPS on a real device
   * @return {boolean} code indicating whether the GPS was started successfully.
   * GPS errors can be handled by handling the gpserror event.
   */
  startGps() {
    return o(this, M) === null ? (c(this, M, navigator.geolocation.watchPosition(
      (e) => {
        l(this, h, H).call(this, e);
      },
      (e) => {
        o(this, g).gpserror ? o(this, g).gpserror(e.code) : alert(`GPS error: code ${e.code}`);
      },
      {
        enableHighAccuracy: !0
      }
    )), !0) : !1;
  }
  /**
   * Stop the GPS on a real device
   * @return {boolean} true if the GPS was stopped, false if it could not be
   * stopped (i.e. it was never started).
   */
  stopGps() {
    return o(this, M) !== null ? (navigator.geolocation.clearWatch(o(this, M)), c(this, M, null), !0) : !1;
  }
  /**
   * Send a fake GPS signal. Useful for testing on a desktop or laptop.
   * @param {number} lon - The longitude.
   * @param {number} lat - The latitude.
   * @param {number} elev - The elevation in metres. (optional, set to null
   * for no elevation).
   * @param {number} acc - The accuracy of the GPS reading in metres. May be
   * ignored if lower than the specified minimum accuracy.
   */
  fakeGps(e, t, i = null, s = 0) {
    i !== null && this.setElevation(i), l(this, h, H).call(this, {
      coords: {
        longitude: e,
        latitude: t,
        accuracy: s
      }
    });
  }
  /**
   * Convert longitude and latitude to three.js/WebGL world coordinates.
   * Uses the specified projection, and negates the northing (in typical
   * projections, northings increase northwards, but in the WebGL coordinate
   * system, we face negative z if the camera is at the origin with default
   * rotation).
   * @param {number} lon - The longitude.
   * @param {number} lat - The latitude.
   * @return {Array} a two member array containing the WebGL x and z coordinates
   */
  lonLatToWorldCoords(e, t) {
    const i = o(this, w).project(e, t);
    if (o(this, f))
      i[0] -= o(this, f)[0], i[1] -= o(this, f)[1];
    else
      throw "No initial position determined";
    return [i[0], -i[1]];
  }
  /**
   * Add a new AR object at a given latitude, longitude and elevation.
   * @param {THREE.Mesh} object the object
   * @param {number} lon - the longitude.
   * @param {number} lat - the latitude.
   * @param {number} elev - the elevation in metres 
   * (if not specified, 0 is assigned)
   * @param {Object} properties - properties describing the object (for example,
   * the contents of the GeoJSON properties field).
   */
  add(e, t, i, s, d = {}) {
    e.properties = d, l(this, h, D).call(this, e, t, i, s), this.scene.add(e);
  }
  /**
   * Set the elevation (y coordinate) of the camera.
   * @param {number} elev - the elevation in metres.
   */
  setElevation(e) {
    this.camera.position.y = e;
  }
  /**
   * Add an event handler.
   * Currently-understood events: "gpsupdate" and "gpserror".
   * The former fires when a GPS update is received, and is passed the
   * standard Geolocation API position object, along with the distance moved
   * since the last GPS update in metres.
   * The latter fires when a GPS error is generated, and is passed the
   * standard Geolocation API numerical error code.
   * @param {string} eventName - the event to handle.
   * @param {Function} eventHandler - the event handler function.
   * @listens LocationBased#gpsupdate
   * @listens LocationBased#gpserror
   */
  on(e, t) {
    o(this, g)[e] = t;
  }
}
w = new WeakMap(), g = new WeakMap(), v = new WeakMap(), O = new WeakMap(), E = new WeakMap(), M = new WeakMap(), f = new WeakMap(), h = new WeakSet(), D = function(e, t, i, s) {
  const d = this.lonLatToWorldCoords(t, i);
  s !== void 0 && (e.position.y = s), [e.position.x, e.position.z] = d;
}, _ = function(e, t) {
  c(this, f, o(this, w).project(e, t));
}, H = function(e) {
  let t = Number.MAX_VALUE;
  console.log(`#gpsReceived(): position ${e.coords.latitude},${e.coords.longitude}, accuracy ${e.coords.accuracy}, accuracy limit ${o(this, E)}`), e.coords.accuracy <= o(this, E) && (o(this, v) === null ? c(this, v, {
    latitude: e.coords.latitude,
    longitude: e.coords.longitude
  }) : t = l(this, h, q).call(this, o(this, v), e.coords), t >= o(this, O) && (o(this, v).longitude = e.coords.longitude, o(this, v).latitude = e.coords.latitude, this.initialPosition || l(this, h, _).call(this, e.coords.longitude, e.coords.latitude), l(this, h, D).call(this, this.camera, e.coords.longitude, e.coords.latitude), o(this, g).gpsupdate && o(this, g).gpsupdate(e, t)));
}, /**
 * Calculate haversine distance between two lat/lon pairs.
 *
 * Taken from original A-Frame AR.js location-based components
 */
q = function(e, t) {
  const i = a.MathUtils.degToRad(t.longitude - e.longitude), s = a.MathUtils.degToRad(t.latitude - e.latitude), d = Math.sin(s / 2) * Math.sin(s / 2) + Math.cos(a.MathUtils.degToRad(e.latitude)) * Math.cos(a.MathUtils.degToRad(t.latitude)) * (Math.sin(i / 2) * Math.sin(i / 2));
  return 2 * Math.atan2(Math.sqrt(d), Math.sqrt(1 - d)) * 6371e3;
};
class V {
  /**
   * Create a WebcamRenderer.
   * @param {THREE.WebGLRenderer} renderer - the Three.js renderer.
   * @param {string} videoElementSelector - selector to obtain the HTML video 
   * element to render the webcam feed. If a falsy value (e.g. null or 
   * undefined), a video element will be created.
   * @options {Object} - options to use for initialising the camera. Currently
   * width and height properties are understood.
   */
  constructor(e, t, i) {
    this.renderer = e, this.renderer.autoClear = !1, this.sceneWebcam = new a.Scene();
    let s;
    t ? s = document.querySelector(t) : (s = document.createElement("video"), s.setAttribute("autoplay", !0), s.setAttribute("playsinline", !0), s.style.display = "none", document.body.appendChild(s)), this.geom = new a.PlaneGeometry(), this.texture = new a.VideoTexture(s), this.material = new a.MeshBasicMaterial({ map: this.texture });
    const d = new a.Mesh(this.geom, this.material);
    if (this.sceneWebcam.add(d), this.cameraWebcam = new a.OrthographicCamera(
      -0.5,
      0.5,
      0.5,
      -0.5,
      0,
      10
    ), navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      const p = {
        video: {
          width: (i == null ? void 0 : i.width) || 1280,
          height: (i == null ? void 0 : i.height) || 720,
          facingMode: "environment"
        }
      };
      navigator.mediaDevices.getUserMedia(p).then((y) => {
        console.log("using the webcam successfully..."), s.srcObject = y, s.play();
      }).catch((y) => {
        setTimeout(() => {
          alert(
            `Webcam Error
Name: ` + y.name + `
Message: ` + y.message
          );
        }, 1e3);
      });
    } else
      setTimeout(() => {
        alert("sorry - media devices API not supported");
      }, 1e3);
  }
  /**
   * Update the webcam.
   * Should be called from your Three.js rendering (animation) function.
   */
  update() {
    this.renderer.clear(), this.renderer.render(this.sceneWebcam, this.cameraWebcam), this.renderer.clearDepth();
  }
  /**
   * Free up the memory associated with the webcam.
   * Should be called when your application closes.
   */
  dispose() {
    this.material.dispose(), this.texture.dispose(), this.geom.dispose();
  }
}
const F = new a.Vector3(0, 0, 1), C = new a.Euler(), S = new a.Quaternion(), G = new a.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)), N = { type: "change" };
class X extends a.EventDispatcher {
  /**
   * Create an instance of DeviceOrientationControls.
   * @param {Object} object - the object to attach the controls to
   * (usually your Three.js camera)
   */
  constructor(e) {
    super(), window.isSecureContext === !1 && console.error("THREE.DeviceOrientationControls: DeviceOrientationEvent is only available in secure contexts (https)");
    const t = this, i = 1e-6, s = new a.Quaternion();
    this.object = e, this.object.rotation.reorder("YXZ"), this.enabled = !0, this.deviceOrientation = {}, this.screenOrientation = 0, this.alphaOffset = 0, this.deviceOrientationEventName = "ondeviceorientationabsolute" in window ? "deviceorientationabsolute" : "deviceorientation";
    const d = function(r) {
      t.deviceOrientation = r;
    }, p = function() {
      t.screenOrientation = window.orientation || 0;
    }, y = function(r, b, P, T, A) {
      C.set(P, b, -T, "YXZ"), r.setFromEuler(C), r.multiply(G), r.multiply(S.setFromAxisAngle(F, -A));
    };
    this.connect = function() {
      p(), window.DeviceOrientationEvent !== void 0 && typeof window.DeviceOrientationEvent.requestPermission == "function" ? window.DeviceOrientationEvent.requestPermission().then(function(r) {
        r == "granted" && (window.addEventListener("orientationchange", p), window.addEventListener(t.deviceOrientationEventName, d));
      }).catch(function(r) {
        console.error("THREE.DeviceOrientationControls: Unable to use DeviceOrientation API:", r);
      }) : (window.addEventListener("orientationchange", p), window.addEventListener(t.deviceOrientationEventName, d)), t.enabled = !0;
    }, this.disconnect = function() {
      window.removeEventListener("orientationchange", p), window.removeEventListener(t.deviceOrientationEventName, d), t.enabled = !1;
    }, this.update = function() {
      if (t.enabled === !1) return;
      const r = t.deviceOrientation;
      if (r) {
        const b = r.alpha ? a.MathUtils.degToRad(r.alpha) + t.alphaOffset : 0, P = r.beta ? a.MathUtils.degToRad(r.beta) : 0, T = r.gamma ? a.MathUtils.degToRad(r.gamma) : 0, A = t.screenOrientation ? a.MathUtils.degToRad(t.screenOrientation) : 0;
        y(t.object.quaternion, b, P, T, A), 8 * (1 - s.dot(t.object.quaternion)) > i && (s.copy(t.object.quaternion), t.dispatchEvent(N));
      }
    }, this.dispose = function() {
      t.disconnect();
    }, this.connect();
  }
}
class k {
  /**
   * Create a ClickHandler.
   * @param {THREE.WebGLRenderer} - The Three.js renderer on which the click
   * events will be handled.
   */
  constructor(e) {
    this.raycaster = new a.Raycaster(), this.normalisedMousePosition = new a.Vector2(null, null), e.domElement.addEventListener("click", (t) => {
      this.normalisedMousePosition.set(
        t.clientX / e.domElement.clientWidth * 2 - 1,
        -(t.clientY / e.domElement.clientHeight * 2) + 1
      );
    });
  }
  /**
   * Cast a ray into the scene to detect objects.
   * @param {THREE.Camera} - The active Three.js camera, from which the ray
   * will be cast.
   * @param {THREE.Scene} - The active Three.js scene, which the ray will be
   * cast into.
   * @return {Array} - array of all intersected objects.
   */
  raycast(e, t) {
    if (this.normalisedMousePosition.x !== null && this.normalisedMousePosition.y !== null) {
      this.raycaster.setFromCamera(this.normalisedMousePosition, e);
      const i = this.raycaster.intersectObjects(t.children, !1);
      return this.normalisedMousePosition.set(null, null), i;
    }
    return [];
  }
}
export {
  k as ClickHandler,
  X as DeviceOrientationControls,
  $ as LocationBased,
  I as SphMercProjection,
  V as WebcamRenderer
};
